# -*- coding: utf-8 -*-
"""Dynamic_pricing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PS2W6HRmXMCLnIulP0TQ9ZTAavrFH0RB
"""

#importing library packages
import pickle
import joblib
import pandas as pd
import json
import numpy as np
#from pandas import json_normalize

#for cheching if the datatype is string
from pandas.api.types import is_string_dtype

#installing haversine
# !pip install haversine

#importing haversine function from haversine library
from haversine import haversine

#Creating reference to saved model file
filename = "D:\Project Space\GrydPark\GrydBackend\sql_app\prediction_model.pkl"

# Load the model and metadata from the pickle file
with open('D:\Project Space\GrydPark\GrydBackend\sql_app\prediction_model.pkl', 'rb') as f:
  model = pickle.load(f)
  rmse_score = pickle.load(f)

# Access the RMSE value from the metadata
rmse = rmse_score['rmse']

# #loading csv file into pandas dataframe
# data = pd.read_csv('Final_Parking_Data.csv',index_col=0)

# # Coordinates of centre of winnipeg
# data['lon_win'] = -97.138451
# data['lat_win'] = 49.895077

# #Printing dataframe
# data.head()

#Defining Haversine function to calculate distance between two quardinate points
from math import radians, cos, sin, asin, sqrt

def custom_haversine(k):
    """
    Calculate the great circle distance between two points 
    on the earth (specified in decimal degrees)
    """
    # convert decimal degrees to radians 
    k.Longitude, k.Latitude, k.lon_win, k.lat_win = map(radians, [k.Longitude, k.Latitude, k.lon_win, k.lat_win])

    # haversine formula 
    dlon = k.lon_win - k.Longitude  
    dlat = k.lat_win - k.Latitude  
    a = sin(dlat/2)**2 + cos(k.Latitude) * cos(k.lat_win) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a))
    km = 6371 * c
    
    return km

#pinting column names
#Some of the columns in the list below are not expected by the model
# data.columns

#Creating a python Dictionary to test the function
#you can take reference from this to build and input your own dictionary
# p_dict = {'index': 6, 
#           'Address': '2211 McPhillips Street, Winnipeg, MB, Canada, Winnipeg', 
#           'Postal_Code': 30, 
#           'Postalcode': 'R2V3M5', 
#           'Latitude': 49.950793, 
#           'Longitude': -97.148556, 
#           'Covered_Parking': 0, 
#           'Electric_charger': 0, 
#           'Rating': 0.0, 
#           'Reservation_Count': 2, 
#           'Reserved_hours': 13, 
#           'Spot_Count': 2, 
#           'Hourly_Rate': 1.0, 
#           'Daily_Rate': 5.0, 
#           'UtilizationByHours': 0.0, 
#           'Bus_Nearby': 0,
#           }

#Dynamic price prediction function  
def dynamic_pricing(features, daily_ratio = 4.8, weekly_ratio = 4.8*5, monthly_ratio = 4.8*25):
  
  #Converting 1D python dictionary into 2D Json dictionary
  features = {'0': features}

  #Converting 2D python Dictionary into pandas dataframe
  data = pd.DataFrame.from_dict(features, orient = 'index')

  #Extracting desired features
  #these are the columns that are expected by the machine learning model for presiction
  data = data.loc[:, ['Latitude','Longitude','Covered_Parking', 'Electric_charger', 'Rating', 'Reserved_hours', 'Spot_Count','UtilizationByHours','Bus_Nearby']]

  #Rename colummns
  data.columns  = ['Latitude','Longitude','Covered_Parking', 'Electric_charger' , 'Rating','Reserved_hours','Spot_Count','UtilizationByHours','Bus_Nearby']

  #Checking number of features
  if len(data.axes[1])!=9:
    print("ERROR: No suitable number of features for machine learning model.")

  # Coordinates of centre of winnipeg
  data['lon_win'] = -97.138451
  data['lat_win'] = 49.895077
  
  #Creating Feature to get distance of each parking spot from center of winnipeg
  data['Distance_from_center'] =data.apply(custom_haversine, axis = 1)

  #Validation
  if ('Longitude' not in data) or data.Longitude.isnull().any() or is_string_dtype(data['Longitude']):
    data['Longitude'] = 0

  if ('Latitude' not in data) or data.Latitude.isnull().any() or is_string_dtype(data['Latitude']):
    data['Latitude'] = 0

  if ('Covered_Parking' not in data) or data.Covered_Parking.isnull().any() or is_string_dtype(data['Covered_Parking']) or (data['Covered_Parking'][0]<0) or (data['Covered_Parking'][0]>1):
    data['Covered_Parking'] = 0

  if 'Electric_charger' not in data or data.Electric_charger.isnull().any() or is_string_dtype(data['Electric_charger']) or (data['Electric_charger'][0]<0) or (data['Electric_charger'][0]>1):
    data['Electric_charger'] = 0

  if 'Rating' not in data or data.Rating.isnull().any() or is_string_dtype(data['Rating']):
    data['Rating'] = 0

  if 'Reserved_hours' not in data or data.Reserved_hours.isnull().any() or is_string_dtype(data['Reserved_hours']) or (data['Reserved_hours'][0]<0):
    data['Reserved_hours'] = 0

  if 'Spot_Count' not in data or data.Spot_Count.isnull().any() or is_string_dtype(data['Spot_Count']) or (data['Spot_Count'][0]<0):
    data['Spot_Count'] = 0

  if ('UtilizationByHours' not in data) or data.UtilizationByHours.isnull().any() or is_string_dtype(data['UtilizationByHours']) or (data['UtilizationByHours'][0]<0):
    data['UtilizationByHours'] = 0
 
  #Extracting desired features
  #these are the columns that are expected by the machine learning model for presiction
  data = data.loc[:, ['Covered_Parking', 'Electric_charger', 'Rating', 'Reserved_hours', 'Spot_Count','UtilizationByHours', 'Distance_from_center','Bus_Nearby']]

  #Rename colummns
  #data.columns  = ['Covered_Parking', 'Electric_charger' , 'Rating','Reserved_hours','Spot_Count','Daily_Rate','Evening_Rate','24/7','Commuter','Eveninng_and_Weekends']
  
  #Loading the trained model
  loaded_model = joblib.load(filename)

  #extracting desired features for model
  #data = data[['Covered_Parking', 'Electric_charger', 'Rating', 'Reserved_hours', 'Spot_Count', 'Daily_Rate', 'Evening_Rate', '24/7', 'Commuter', 'Eveninng_and_Weekends', 'Distance_from_center']]
  
  #making predictions from trained model
  hourly = loaded_model.predict(data)

  #Hard-coding ratios
  #daily_ratio = 4.8
  #weekly_ratio = 4.8*5
  #monthly_ratio = 4.8*25

  #Computing prices
  daily = daily_ratio * hourly
  weekly = weekly_ratio * hourly
  monthly = monthly_ratio * hourly

  #Root mean square error
  std_dev = rmse

  my_dict = {
    'hourly_price' : hourly[0],
    'daily_price': daily[0],
    'weekly_price': weekly[0],
    'monthly_price': monthly[0],
    'Std_deviation': std_dev
  }

  # my_list = json.dumps(my_dict)

  #returning predicted prices
  #return(hourly,daily,weekly,monthly, std_dev)

  #returning output as a dictionary
  return(my_dict)

#calling the function to predict price
#predicted_price = dynamic_pricing(p_dict)

#printing the predicted price
#print(predicted_price)

